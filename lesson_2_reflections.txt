What happens when you initialize a repository? Why do you need to do it?

When you initialize a git repository, git creates all the data structured that it needs in order to track all the
changes and related info about the files in the repository. It is necessary to do this, because is the way that
you let git know that that directory would be a repository (so, it must to track it) and not an ordinary file
directory.

How is the staging area different from the working directory and the repository? What value do you think it offers?

The working directory is the normal file directory in your file system. It can contains files that you want to keep
tracked on the repository and other files that you want the repository to ignore them. Meanwhile, the repository is
where git keep the files actually tracked. When you commit some changes, they go to the repository. Furthermore, the
staging area is like a halfway place where you can add each changed file that you would want to include in your next
commit to the repository. That's allow you not to include always all the changed files in your commit, but choose only
those files that you want to keep logically together in the same change commit.

How can you use the staging area to make sure you have one commit per logical change?

You choose what changed files you include in the staging area before a commit. Then, using "git diff --staged" you can
actually know what changes are going to be commited, because this command compares the staging area with the most
recent commit in the repository (and that is what is going to be commited). If the changes returned by this command
contain a unique logical change, you are right and sure that you are going to make one commit per logical change.

What are some situations when branches would be helpful in keeping your history organized? How would branches help?

They are very useful, as they allows you to introduce changes in your project separately of the "official" version (the
master branch), try them in that separate place and then, if you decide that, include them in the official version. In
addition, when working in multiple new features in the some project at the same time, it allows you to make those
changes independently, so when it comes the moment when you must to build a new release of your system, you can decide
to include only some of those new features (and postpone the rest of them for a later release). I think that branching
and merging is one of the most useful features in version control system, and we (my team and me) use them a lot in our
daily work in our projects.

How do the diagrams help you visualize the branch structure?

They are really helpful, as with them you can see at a glance all the branch structure of your repository. That's is,
which commits are related with each other (who is the parent of each one), how many different branches do you have (and
where they were created (or merged to another one), etc. In addition, you can easyly see the reachability of all your
commits (and notice if there are some of them that are totally unreachable).

What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

By merging one branch into another, what we make is to include all the changes made on the first branch (since the last
common point, or commit, the two branches have in their history) into the second one (the objective branch of the
merge). We represent it in that way in the diagram because after the merge, we updated the objective branch tip point
in order to be in the new commit generated by the merge, and from there we have access to all previous commits on both
branches, so the new commit has got two parents: the most recent commit in each branch before the merge.
